/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Chopper_over
*
* %I
* Written by: Peter Willendrup
* Date: March 9 2006
* Version: $Revision: 4983 $
* Origin: Risoe
* Release: McStas 2.0
* Based on Chopper (Philipp Bernhardt), Jitter and beamstop from work by 
* Kaspar Hewitt Klenoe (jan 2006), adjustments by Rob Bewey (march 2006)
*
* %D
* Models a disc chopper with overradial slits, 
* At time t=0, the centre of the first slit opening will be situated at the
* vertical axis when phase=0.
*
* For more complicated gemometries, see component manual example of DiskChopper GROUPing.
*
* If the chopper is the 1st chopper of the instrument, it sets t time with phase
* - Only relevant for when using continuous source modules.
*
* Example: DiskChopper(r_out=0.2, theta_0=10, nu=41.7, delay=0, isfirst=1) First chopper
*          DiskChopper(r_out=0.2, theta_0=10, nu=41.7, delay=0, isfirst=0)
*
* %P
* INPUT PARAMETERS:
*
* theta_0: (deg)    Angular width of the slits.
* yheight: (m)      Slit height (if = 0, equal to r_out). Auto centering of beam at half height.
* r_out:  (m)      r_out of the disc
* nu:      (Hz)     Frequency of the Chopper, omega=2*PI*nu
*                     (algebraic sign defines the direction of rotation)
*
* Optional parameters:
* isfirst: (0/1)    Set it to 1 for the first chopper position in a cw source
*                     (it then spreads the neutron time distribution)
* n_pulse: (1)      Number of pulses (Only if isfirst)
* jitter   (s)      Jitter in the time phase
* abs_out: (0/1)    Absorb neutrons hitting outside of chopper r_out?
* delay:   (s)      Time 'delay'.
* phase:   (deg)    Angular 'delay' (overrides delay)
* xwidth:  (m)      Horizontal slit width opening at beam center 
* verbose: (1)      Set to 1 to display Disk chopper configuration
*
* %E
*******************************************************************************/

DEFINE COMPONENT Chopper_over
DEFINITION PARAMETERS ()
SETTING PARAMETERS (theta_0=0, r_out=0.5, yheight, nu, alpha, beta, jitter=0, delay=0, isfirst=0, n_pulse=1, abs_out=1, phase=0, xwidth=0, verbose=0)
OUTPUT PARAMETERS (Tg, To, delta_y, height,omega)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */ 
DECLARE
 %{
  double Tg,To,delta_y,height,omega, r_in;
 %}

INITIALIZE
 %{
      /* If slit height 'unset', assume full opening */
      if (yheight == 0) {
        height=r_out;
      } else {
        height=yheight;
      }
      delta_y = r_out-height/2; /* r_out at beam center */
	r_in=r_out-height;
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && r_out) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);
      
      if (theta_0 <= 0 || r_out <=0)
      { fprintf(stderr,"DiskChopper: %s: theta_0 and r_out must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>r_out) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < r_out\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside r_out %g [m]\n", NAME_CURRENT_COMP, r_out);
      }
      
      theta_0*=DEG2RAD;
	alpha*=DEG2RAD;
	beta*=DEG2RAD;

      
      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);  
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      } 
      
      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega);
      
      /* How long can neutrons pass the Chopper at a single point */
      //To=theta_0/fabs(omega);
      
      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);
      
      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             angle=%g [deg] height=%g [m], width=%g [m] at r_out=%g [m]\n",
           theta_0*RAD2DEG, height, xwidth, delta_y);
      }
 %}

TRACE
 %{
    double toff,r;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;
	r=sqrt(x*x+yprime*yprime);
      /* How long can neutrons pass the Chopper at a single point */
    To=(theta_0+(alpha+beta)*(r-r_in)/(r_out-r_in))/fabs(omega);
	delay=(phase+alpha*(r-r_in)/(r_out-r_in))*omega;
    
    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>r_out*r_out) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=r_out? */
    if ((x*x+yprime*yprime)<(r_in*r_in)) {
      ABSORB;
    }
    
    
    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + jitter*randnorm() + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= theta_0/2.0/PI; 
      }
    else 
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - jitter*randnorm());

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB; 
      }
    SCATTER;
    
 %}

MCDISPLAY
%{
  
  int j;
  /* Arrays for storing geometry of slit/beamstop */
  magnify("xy");
  circle("xy", 0, -delta_y, 0, r_out);
  
  /* Drawing the slit(s) */
  for (j=0; j<1; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/1) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */
       
    line(
      r_out*sin(tmin),          r_out*cos(tmin)-delta_y,          0,
      (r_out-height)*sin(tmin), (r_out-height)*cos(tmin)-delta_y, 0
      );
    line(
      (r_out-height)*sin(tmin), (r_out-height)*cos(tmin)-delta_y, 0,
      (r_out-height)*sin(tmax), (r_out-height)*cos(tmax)-delta_y, 0);
    line(
      (r_out-height)*sin(tmax), (r_out-height)*cos(tmax)-delta_y, 0,
      r_out*sin(tmax),          r_out*cos(tmax)-delta_y,          0);
  }
%}

END
