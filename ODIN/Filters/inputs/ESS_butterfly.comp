/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2016, All rights reserved
*         DTU Physics, Kongens Lyngby, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: ESS_butterfly
*
* %I
*
* Written by: Peter Willendrup and Esben Klinkby
* Date: April-May 2016
* Version: $Revision$
* Release: McStas 2.3
* Origin: DTU
*
* ESS butterfly moderator, 2016 revision
*
* %D
* ESS butterfly moderator with automatic choice of coordinate system, with origin
* placed at relevant "Moderator Focus Coordinate System" depending on sector location.
*
* To select beamport N 5 simply use 
*  
*  COMPONENT Source = ESS_butterfly(sector="N",beamline=5,Lmin=0.1,Lmax=20,dist=2,
*                                   cold_frac=0.5, yheight=0.03,focus_xw=0.1, focus_yh=0.1)
*
* <b>Geometry</b>
* The geometry corresponds correctly to the latest release of the butterfly moderator,
* including changes warranted by the ESS CCB in July 2016.
*
* <b>Brilliances</b>
* The internal brilliance-functions are howerver still based on the previous MCNP study
* by Troels Schoenfeldt as included in the ESS_moderator component, with the so-called BF2 
* design and performed at beamport positions 5, ..., 55 degrees measured from the central
* position of the beam extraction. A nearest neighbour "interpolation"/discretisation is 
* performed on that basis. Hence, the performance is symmetric in all sectors for now, 
* i.e. beamline 3 performs the same in all of N, W, S and E.
* In terms of intensity/performance the component agrees with the previous ESS_moderator
* (McStas 2.2a version - 2.3 version had a bug) within apx. 10%.
* <b>We expect to release a new set of brilliance functions later in 2016. These are 
* expected to include more realistic brilliances in terms of variation across sectors and
* potentially also performance losses due to engineering reality. </b>
* 
* <b>Engineering reality</b>
* An ad-hoc method for future implementation of "engineering reality" is included, use the
* "performance" parameter to down-scale performance uniformly across all wavelengths.
*
* %P
* Input parameters:
* sector:          [str] Defines the 'sector' of your instrument position. Valid values are "N","S","E" and "W"
* beamline:        [1]   Defines the 'beamline number' of your instrument position. Valid values are 1..10 or 1..11 depending on sector
* yheight:         [m]   Defines the moderator height. Valid values are 0.03 m and 0.06 m
* cold_frac:       [1]   Defines the statistical fraction of events emitted from the cold part of the moderator
* c_performance:   [1]   Cold brilliance scalar performance multiplicator 0 < c_performance <= 1
* t_performance:   [1]   Thermal brilliance scalar performance multiplicator 0 < t_performance <= 1
* Lmin:            [AA]  Minimum wavelength simulated
* Lmax:            [AA]  Maximum wavelength simulated
* target_index:    [1]   Relative index of component to focus at, e.g. next is +1 this is used to compute 'dist' automatically.
* dist:            [m]   Distance from origin to focusing rectangle; at (0,0,dist) - alternatively use target_index
* focus_xw:        [m]   Width of focusing rectangle
* focus_yh:	   [m]   Height of focusing rectangle
* tmax_multiplier: [1]   Defined maximum emission time at moderator, tmax= tmax_multiplier * ESS_PULSE_DURATION.
* acc_power:       [MW]  Accelerator power in MW
* n_pulses:        [1]   Number of pulses simulated. 0 and 1 creates one pulse. 
*
* %E
*******************************************************************************/

DEFINE COMPONENT ESS_butterfly
DEFINITION PARAMETERS ()
SETTING PARAMETERS (string sector="N",int beamline=1, yheight=0.03, cold_frac=0.5, int target_index=0, dist=0, focus_xw=0, focus_yh=0, 
		    c_performance=1, t_performance=1, Lmin, Lmax, tmax_multiplier=3, int n_pulses=1, acc_power=5)
OUTPUT PARAMETERS (cx, cz, sign_bl_angle, orientation_angle,jmax,C0_x,C0_z,C1_x,C1_z,C2_x,C2_z,T1_x,T1_z,T2_x,T2_z,rC0_x,rC0_z,rC1_x,rC1_z,rC2_x,rC2_z,rT1_x,rT1_z,rT2_x,rT2_z,tx,ty,tz,r11,r12,r21,r22,xf,yf,zf,w_mult,w_stat,w_geom,w_focus,w_geom_c,w_geom_t,tx,ty,tz,tfocutmps_width, tfocus_time, dt,lambda,l_range,k,v,r,dx,dy,dz,internal_angle,x0,z0, cos_beamport_angle, sin_beamport_angle, cos_thermal, cos_cold)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */

DECLARE
%{
  /* Centering-parameters, which sector are we in? */
  double cx, cz;
  int sign_bl_angle;
  double orientation_angle;
  /* 10 beamlines in sector N and E  - plus one location added for drawing */
  double BeamlinesN[] = { 30.0,  36.0,  42.0,  48.0,  54.0,  60.0,  66.0,  72.0,  78.0,  84.0,  90.0};
  double BeamlinesE[] = {-30.0, -36.0, -42.0, -48.0, -54.0, -60.0, -66.0, -72.0, -78.0, -84.0, -90.0};
  /* 11 beamlines in sector S and W - plus one location added for drawing */
  double BeamlinesW[] = { 150.0,  144.7,  138.0,  132.7,  126.0,  120.7,  114.0,  108.7,  102.0,  96.7,  90.0,  84.0};
  double BeamlinesS[] = {-150.0, -144.7, -138.0, -132.7, -126.0, -120.7, -114.0, -108.7, -102.0, -96.7, -90.0, -84.0};
  double* Beamlines;
  int jmax;
  /* 'Corner' parametrization, i.e. where are the limits of the moderators */
  double C0_x,C0_z,C1_x,C1_z,C2_x,C2_z;
  double T1_x,T1_z,T2_x,T2_z;
  /* - plus rotated versions of the same... */
  double rC0_x,rC0_z,rC1_x,rC1_z,rC2_x,rC2_z;
  double rT1_x,rT1_z,rT2_x,rT2_z;
  double tx,ty,tz;
  double r11, r12, r21, r22;
  int iscold;
  double xtmp;
  double delta_y;
  double xf, yf, zf;
  double w_mult,w_stat;
  double w_geom, w_focus;
  double w_geom_c, w_geom_t;
  double tx,ty,tz;
  int isleft;
  double  tfocus_width,  tfocus_time,  dt, lambda, l_range;
  %include "ESS_butterfly-lib"
  ess_moderator_struct modextras;
  /* Cold and thermal function pointers */
  functype cold_bril;
  functype thermal_bril;
  double k,v,r;
  double dx,dy,dz;
  /* variables needed to correct for the emission surface angle */
  double internal_angle;

  int nearest_angle(double angle) {
    int AngleList[] = {5, 15, 25, 35, 45, 55};
    double diff = 180;
    int jmin=-1;
    int j;
    for (j=0; j<6; j++) {
      if (fabs(AngleList[j]-angle) < diff) {
	diff = fabs(AngleList[j]-angle);
	jmin = j;
      }
    }
    return AngleList[jmin];
  }
  
  double x0,z0;
  double cos_beamport_angle, sin_beamport_angle, cos_thermal, cos_cold;
%}

INITIALIZE
%{
  /* Centering-parameters, which sector are we in? */
  if (strcasestr(sector,"N")) {
    cx = 0.117; cz=0.0; sign_bl_angle=1;
    orientation_angle = BeamlinesN[beamline-1];
    Beamlines = BeamlinesN;
    jmax=10;
    T1_x=0;
    T1_z=0;
    T2_x=-0.108;
    T2_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=0.072;
    C2_z=-0.072*sin(24.24*DEG2RAD);
    isleft=1;
  } else if (strcasestr(sector,"W")) {
    cx = 0.0; cz=0.0; sign_bl_angle=-1;
    orientation_angle = BeamlinesW[beamline-1]; 
    Beamlines = BeamlinesW;
    jmax=11;
    T1_x=0;
    T1_z=0;
    T2_x=0.108;
    T2_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=-0.072;
    C2_z=-0.072*sin(24.24*DEG2RAD);
    isleft=-1;
  } else if (strcasestr(sector,"S")) {
    cx = 0.0; cz=-0.185; sign_bl_angle=1;
    orientation_angle = BeamlinesS[beamline-1]; 
    Beamlines = BeamlinesS;
    jmax=11;
    T1_x=0;
    T1_z=0;
    T2_x=0.108;
    T2_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=-0.072;
    C2_z=0.072*sin(24.24*DEG2RAD);
    isleft=1;
  } else if (strcasestr(sector,"E")) {
    cx = 0.117; cz=-0.185; sign_bl_angle=-1;
    orientation_angle = BeamlinesE[beamline-1]; 
    Beamlines = BeamlinesE;
    jmax=10;
    T1_x=0;
    T1_z=0;
    T2_x=-0.108;
    T2_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=0.072;
    C2_z=0.072*sin(24.24*DEG2RAD);
    isleft=-1;
  } else {
    fprintf(stderr,"%s: Sector %s is undefined, please use N, W, S or E!\n", NAME_CURRENT_COMP,sector);
    exit(-1);
  }
  if (beamline > jmax || beamline <= 0 ) {
    fprintf(stderr,"%s: beamline no %i is undefined in sector %s, please use 1 <= beamline <= %i\n", NAME_CURRENT_COMP, beamline, sector, jmax);
    exit(-1);
  }
  internal_angle=90-fabs(orientation_angle);
  modextras.beamportangle=nearest_angle(fabs(internal_angle));
  /* Direction-cosines for use with e.g. Brilliance_monitor */
  cos_beamport_angle=cos(modextras.beamportangle*DEG2RAD);
  sin_beamport_angle=sin(modextras.beamportangle*DEG2RAD);
  /* correction for projection along the beam / projection on the z=0 plane */
  cos_thermal=cos_beamport_angle;
  cos_cold=cos((modextras.beamportangle-24.24)*DEG2RAD);
  printf("Setting up for sector %s, beamline %i, global orientation angle is %g, internal angle %g, cosines %g(t) and %g(c)\n",sector,beamline,orientation_angle,modextras.beamportangle,cos_thermal,cos_cold);
  if (c_performance <= 0 || c_performance > 1) {
    fprintf(stderr,"%s: Cold performance scalar of %g is not allowed. Please select 0 < c_performance <= 1\n", NAME_CURRENT_COMP, c_performance);
    exit(-1);
  }
  if (t_performance <= 0 || t_performance > 1) {
    fprintf(stderr,"%s: Thermal performance scalar of %g is not allowed. Please select 0 < c_performance <= 1\n", NAME_CURRENT_COMP, t_performance);
    exit(-1);
  }
  if (Lmin>=Lmax || Lmin <= 0 || Lmax < 0) {
    printf("%s: Unmeaningful definition of wavelength range!\nPlease select Lmin, Lmax > 0 and Lmax > Lmin.\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(-1);
  }
  /* Figure out where to aim */
  if (target_index && !dist)
  {
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &tx, &ty, &tz);
    dist=sqrt(tx*tx+ty*ty+tz*tz);
  } else if (!target_index && !dist) {
    printf("ESS_butterfly: %s: Please choose to set either the dist parameter or specify a target_index.\nExit\n", NAME_CURRENT_COMP);
    exit(-1);
  } else {
    tx=0; ty=0; tz=dist;
  }
  printf("Focusing at rectagle sized %g x %g \n positioned at location %g %g %g (target_index %i and dist %g)\n", focus_xw, focus_yh, tx, ty, tz, target_index, dist);
  /* Issue warning if dist < 2m - TODO */
  
  printf("Cold and Thermal brilliance performance multiplicators are c_performance=%g and t_performance=%g\n", c_performance, t_performance);
  
  /* Calculate orientation matrix for the display and calculations */
  r11 = cos(DEG2RAD*orientation_angle);
  r12 = -sin(DEG2RAD*orientation_angle);
  r21 = sin(DEG2RAD*orientation_angle);
  r22 = cos(DEG2RAD*orientation_angle);
  
  /* Rotated corrdinates of the emission areas */
  rC1_x = r11*C1_z + r12*C1_x;
  rC1_z = r21*C1_z + r22*C1_x;
  rC2_x = r11*C2_z + r12*C2_x;
  rC2_z = r21*C2_z + r22*C2_x;
  rT1_x = r11*T1_z + r12*T1_x;
  rT1_z = r21*T1_z + r22*T1_x;
  rT2_x = r11*T2_z + r12*T2_x;
  rT2_z = r21*T2_z + r22*T2_x;
  /* Moderator half-height */
  delta_y = yheight/2.0;
  /* Other moderator parms */
  modextras.height_c=yheight;
  modextras.Width_c=0.1;
  modextras.Width_t=0.18;
  modextras.height_t=yheight;
  modextras.tmultiplier=tmax_multiplier;
  modextras.extractionangle=120;
  tfocus_width=0;
  tfocus_time=0;
  dt=0;
  /* Specify brilliance fct.'s */
  cold_bril=ESS_2015_Schoenfeldt_cold;
  thermal_bril=ESS_2015_Schoenfeldt_thermal;
  l_range = Lmax-Lmin;
  /* Weight multipliers */
  w_mult=acc_power/5;
  w_stat=1.0/mcget_ncount();
  w_geom_c  = 0.072*yheight*1.0e4;     /* source area correction */
  w_geom_t  = 0.108*yheight*1.0e4;
  w_mult *= l_range;            /* wavelength range correction */
  n_pulses=(double)floor(n_pulses);
  if (n_pulses == 0) n_pulses=1;
%}

TRACE
%{
  
  /* Cold or thermal event? */
  p=1;
  xtmp = rand01();
  y = randpm1()*delta_y;
  modextras.Y=y;
  if (rand01() < cold_frac) {
    iscold=1;
    x = rC1_x + (rC2_x - rC1_x)*xtmp;
    z = rC1_z + (rC2_z - rC1_z)*xtmp;
    x0 = C1_x + (C2_x - C1_x)*xtmp;
    z0 = C1_z + (C2_z - C1_z)*xtmp;
    /* Geometrical scaling factor - BF2 vs BF1 model */
    /* 10 cm "truncated" to 7.2 cm. */ 
    modextras.X=((-xtmp*0.072)-0.08);
    w_geom=w_geom_c*0.7;
    cold_bril( &t,  &p,  lambda,  tfocus_width,  tfocus_time,  dt, modextras);
  } else {
    iscold=0;
    x = rT1_x + (rT2_x - rT1_x)*xtmp;
    z = rT1_z + (rT2_z - rT1_z)*xtmp;
    x0 = T1_x + (T2_x - T1_x)*xtmp;
    z0 = T1_z + (T2_z - T1_z)*xtmp;
    /* Geometrical scaling factor - BF2 vs BF1 model */
    /* 18 cm compactified to 10.8 cm. */
    modextras.X=((xtmp*0.108)*14.2/10.8-0.0705);
    thermal_bril( &t,  &p,  lambda,  tfocus_width,  tfocus_time,  dt, modextras);
    w_geom=w_geom_t*0.7;
  }

  SCATTER;
  /* Where are we going? */
  randvec_target_rect_real(&xf, &yf, &zf, NULL,
			   tx, ty, tz, focus_xw, focus_yh, ROT_A_CURRENT_COMP, x, y, z, 0);
  w_focus=focus_xw*focus_yh/(tx*tx+ty*ty+tz*tz);
  
  dx = xf-x;
  dy = yf-y;
  dz = zf-z;
  r = sqrt(dx*dx+dy*dy+dz*dz);
  
  lambda = Lmin+l_range*rand01();    /* Choose from uniform distribution */
  //printf("Picked wavelength %g, pointing at %g %g %g / vec %g %g %g / distance %g \n",lambda,xf,yf,zf,dx,dy,dz,r);
  k = 2*PI/lambda;
  v = K2V*k;

  vz = v*dz/r;
  vy = v*dy/r;
  vx = v*dx/r;
   
  if (iscold) {          //case: cold moderator
    cold_bril( &t,  &p,  lambda,  tfocus_width,  tfocus_time,  dt, modextras);
    /* Apply simple engineering reality correction */
    p *= c_performance;
  }  else  {                      //case: thermal moderator
    thermal_bril( &t,  &p,  lambda,  tfocus_width,  tfocus_time,  dt, modextras);
    /* Apply simple engineering reality correction */
    p *= t_performance;
  }
  
  p*=w_stat*w_focus*w_geom*w_mult;
  t+=(double)floor((n_pulses)*rand01())/ESS_SOURCE_FREQUENCY;   /* Select a random pulse */
  

  /* Correct weight for sampling of cold vs. thermal events. */
  if (iscold) {
    p /=cold_frac;
  } else {
    p/=(1-cold_frac);
  }
  SCATTER;

  
%}

MCDISPLAY
%{
%include "ESS_butterfly-geometry.c"
%}

END
